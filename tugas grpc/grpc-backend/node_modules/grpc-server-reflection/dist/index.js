"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addReflection = void 0;
const descriptor_pb_1 = require("google-protobuf/google/protobuf/descriptor_pb");
const reflection_grpc_pb_1 = require("../dist/proto/reflection_grpc_pb");
const reflection_pb_1 = require("../dist/proto/reflection_pb");
const fs_1 = require("fs");
class ReflectionHandler {
    constructor(fileDescriptorSetPath) {
        this.fileDescriptorSet = descriptor_pb_1.FileDescriptorSet.deserializeBinary((0, fs_1.readFileSync)(fileDescriptorSetPath));
    }
    fileBySymbol(symbol) {
        const fileDescriptorProto = this.fileDescriptorSet
            .getFileList()
            .find(file => this.findSymbol(symbol, file) != null);
        return fileDescriptorProto;
    }
    fileByName(filename) {
        const fileDescriptorProto = this.fileDescriptorSet
            .getFileList()
            .find(file => file.getName() === filename);
        return fileDescriptorProto;
    }
    fileContainingExtension(containingType, extensionNumber) {
        return this.fileDescriptorSet.getFileList().find(file => {
            const descriptor = this.findSymbol(containingType, file);
            return (descriptor instanceof descriptor_pb_1.DescriptorProto &&
                descriptor
                    .getExtensionList()
                    .some(extension => extensionNumber === extension.getNumber()));
        });
    }
    getServiceNames() {
        return this.fileDescriptorSet.getFileList().flatMap(files => {
            const packageName = files.getPackage();
            return files
                .getServiceList()
                .flatMap(service => `${packageName}.${service.getName()}`);
        });
    }
    findSymbol(symbol, descriptor, prefix = '') {
        if (descriptor instanceof descriptor_pb_1.FileDescriptorProto) {
            const packageName = descriptor.getPackage();
            const packagePrefix = !packageName ? '' : `${packageName}.`;
            return (descriptor
                .getMessageTypeList()
                .find(type => this.findSymbol(symbol, type, packagePrefix)) ||
                descriptor
                    .getEnumTypeList()
                    .find(type => this.findSymbol(symbol, type, packagePrefix)) ||
                descriptor
                    .getServiceList()
                    .find(type => this.findSymbol(symbol, type, packagePrefix)));
        }
        const fullName = prefix + descriptor.getName();
        if (symbol === fullName) {
            return descriptor;
        }
        if (descriptor instanceof descriptor_pb_1.DescriptorProto) {
            const messagePrefix = `${fullName}.`;
            return (descriptor
                .getNestedTypeList()
                .find(type => this.findSymbol(symbol, type, messagePrefix)) ||
                descriptor
                    .getEnumTypeList()
                    .find(type => this.findSymbol(symbol, type, messagePrefix)));
        }
        if (descriptor instanceof descriptor_pb_1.ServiceDescriptorProto) {
            const servicePrefix = `${fullName}.`;
            return descriptor
                .getMethodList()
                .find(method => this.findSymbol(symbol, method, servicePrefix));
        }
        return undefined;
    }
}
const notFoundError = (type, requested) => new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
    .setErrorCode(5 /*Status.NOT_FOUND*/)
    .setErrorMessage(`${type} not found: ${requested}`));
const NOT_IMPLEMENTED_CALL_ERROR = new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
    .setErrorCode(12 /*Status.UNIMPLEMENTED*/)
    .setErrorMessage('Not implemented'));
const addReflection = (server, fileDescriptorSetPath) => {
    const reflectionHandler = new ReflectionHandler(fileDescriptorSetPath);
    const serviceNames = reflectionHandler.getServiceNames();
    const handleRequest = (request) => {
        switch (request.getMessageRequestCase()) {
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.FILE_BY_FILENAME: {
                const filename = request.getFileByFilename();
                const fileDescriptor = reflectionHandler.fileByName(filename);
                if (!fileDescriptor) {
                    return notFoundError('File', filename);
                }
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                    fileDescriptor.serializeBinary(),
                ]));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.FILE_CONTAINING_SYMBOL: {
                const symbol = request.getFileContainingSymbol();
                const fileDescriptor = reflectionHandler.fileBySymbol(symbol);
                if (!fileDescriptor) {
                    return notFoundError('Symbol', symbol);
                }
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                    fileDescriptor.serializeBinary(),
                ]));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase
                .FILE_CONTAINING_EXTENSION:
                {
                    const extensionRequest = request.getFileContainingExtension();
                    const containingType = extensionRequest.getContainingType();
                    const extensionNumber = extensionRequest.getExtensionNumber();
                    const fileDescriptor = reflectionHandler.fileContainingExtension(containingType, extensionNumber);
                    if (!fileDescriptor) {
                        return notFoundError('Extension', `${containingType}(${extensionNumber})`);
                    }
                    return new reflection_pb_1.ServerReflectionResponse()
                        .setOriginalRequest(request)
                        .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                        fileDescriptor.serializeBinary(),
                    ]));
                }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.LIST_SERVICES: {
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setListServicesResponse(new reflection_pb_1.ListServiceResponse().setServiceList(serviceNames.map(serviceName => new reflection_pb_1.ServiceResponse().setName(serviceName))));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase
                .ALL_EXTENSION_NUMBERS_OF_TYPE:
                {
                    const type = request.getAllExtensionNumbersOfType();
                    return new reflection_pb_1.ServerReflectionResponse().setAllExtensionNumbersResponse(new reflection_pb_1.ExtensionNumberResponse().setBaseTypeName(type));
                }
        }
        return NOT_IMPLEMENTED_CALL_ERROR;
    };
    const reflectionImplementation = {
        serverReflectionInfo: call => {
            call.on('data', (request) => {
                try {
                    call.write(handleRequest(request));
                }
                catch (e) {
                    console.error(e);
                    call.end();
                }
            });
            call.on('end', () => {
                call.end();
            });
        },
    };
    server.addService(reflection_grpc_pb_1.ServerReflectionService, reflectionImplementation);
};
exports.addReflection = addReflection;
//# sourceMappingURL=index.js.map